### 当前状况
- javascript飞速发展，ES2015后，每年会出一个版本，es6更是对es5做了大幅度的修改，包括模块化、
  块级作用域，箭头函数，promise以及一些语法糖比如class和解构赋值等等。
- 同时有了web component 的概念 允许我们自定义HTML标签并在上面绑定行为，有更好的封装，提供的标签有更好的
  语义，更好的模块化，但更好的方案是允许开发者按照自己想法去扩展现有的标签，angular1就做的很好。
- 为了更好的处理HTML5的新API比如一些音视频的处理，出现了webWorker，将多线程编程引入浏览器

### angular1.x的特性与angular对比
以上新技术都是在angular1.x以后出现的，在angular1中没有很好的融合
angular一开始的设计就是在web component的基础上构建并全面支持新标准，对于还没有对新特新作出支持的
浏览器，angular会有polyfill，例如ng-content指令  
angular里引入了webWorker API，允许在另一个线程里面执行密集型计算任务，比如音视频的处理等，从而解放主线程
让他关注与处理用户输入和渲染用户界面。
angular1.x在处理海量数据的时候，每绑定一个数据就会添加一个监视器watcher。一旦digest循环开始运行，他就需
要便利所有监视器，执行与之相关的表达式，并把返回的结果与上一次遍历所获的的结果做比较。这都会拖慢性能，  
而且angular1.x中各个监视器之间还存在很多依赖关系，导致digest循环最少要做俩次，数据才能获得稳定的结果.
angular一开始就考虑webWorker，并基于这一标准实现.
#### angular1.x中的一些问题在angular2中的解决
1. controller  
    angular1.x中最佳实践是：控制器不应该操作DOM，而应该把访问和操作DOM的逻辑分到指令中去。如果
    控制器中有些重复的逻辑，最大的可能就是：把重复的逻辑封装到服务中去，某个控制器用到这些功能，
    就是用依赖注入机制注入这个服务。现实并不是这样，ng-controller指令经常被滥用，导致控制器满
    天飞，angular现在删除了这个指令，并该用组件和指令来代替controller的功能。
2. scope   
    angular1.x中数据绑定机制是利用scope对象来实现的。我们首先在scope对象上添加各种属性，然后
    在模版中显式声明需要绑定的属性。但scope有俩个更重要的指责：*派发事件* 和实现基于 *脏值检测* 的行为。   
    初学者往往要花很大时间去理解scope。 angular直接删除了scope对象。所有表达式都是在特定的UI  
    组件的上下文执行。我们不需要再显式注入scope，只要把属性直接添加到UI组件上，然后进行绑定操作即可。
3. 依赖注入  
    依赖注入一直是angular1.x的一大亮点，给我们更好的代码结构和模块化。新版的依赖注入更灵活，   
    功能更丰富使用ECMAScript2016装饰器的语法对DI进行注解。消除了angular1.x中的一些误区，   
    比如API不统一的问题。
4. 大规模应用  
    在angular1.x中不同监视器之间可以相互依赖，从而导致digest循环必须进行若干次遍历，表达式的
    结果才能趋于稳定。angular2中采用了单向数据流：有更明确的数据流，不同的数据绑定之间没有依赖关系，
    digest循环只进行一次。而且angular采用了TypeScript，编译时有类型监测，减少出错。
5. 模版  
    angular1.x中我们创建一个指令，允许用户通过标签的attribute给它传递一个成员属性。有三种不同的实现方式:  

    ```
    <user name="literal"></user>
    <user name="expression"></user>
    <user name="{{interpolate}}"></user>
    ```
    第一种是传递一个字面量  
    第二种是传递一个字符串，可以当成表达式来执行  
    第三种是在{{}}中传递一个表达式   
    angular2为属性提供了特殊的语法来解决这个问题，属性值会在当前组件的上下文中执行，同时为传递字面量
    提供了不同的语法。
6. 脏值检测  
    angular2中将脏值检测机制提取了出来，并且与框架内核进行了解耦。这样依赖angular2有俩种内置脏值检测机制
    - 动态脏值检测：与angular1.x的脏值检测机制类似，用于不允许eval()的系统中，如CSP和Chrome插件。
    - JIT脏值检测：运行是动态生成脏值检测代码，允许javascript虚拟机进行深度代码优化
