## 第三章 变量的解构赋值
我们学习一个新东西的时候，要知道它是`为了干什么`，还有就是它这样做`有什么好处`，这样会`激起我们持续学习的欲望`。
像我，以前看书的时候会按部就班的跟着一步一步看语法，看了一会儿就厌烦了，就算勉强看完也记住的很少，所以现在
在学习新东西的时候会先找一些用很短的时间可以了解相关功能好处用途之类的文章。再带着兴趣和疑问看相关文档。

而这章呢，最后正好讲的就是这个`解构赋值`的用途。我们来看一下使用这个读着就很拗口的东西有什么好处：


+ `交换变量的值` 我们可以这样使用,这样就不用像以前一样定义一个中间值去交换变量了
```javascript
[x,y] = [y,x]
```
+ `从函数返回多个值` 以前我们想要这样做，只能将这些值放在一个对象或者数组里，即使我们不需要这个数组或对象
```javascript
function a() {
    return [1,2,3]
}
var [a,b,c] = a()
```
+ `函数参数的定义` 
+ `提取JSON数据` 这个很好用，不需要我们对JSON数据进行处理就可以提取其中的值了
```javascript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};
let { id, status, data: number } = jsonData;
console.log(id, status, number);
```
+ `函数参数的默认值` >指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。
这个怎么用还没太看明白  **TODO**
+ `遍历Map结构` 这个可以使用`for...of`循环遍历，方便的获取键值对中的健名或者健值。
```javascript
for (let [key] of map) {
    // ...
}
for (let [,value] of map) {
    // ...
}
```
+ `输入模块的指定方法` 这个我们在vuex中就很常见了，比如说加载mapState和mapMutations啊

好了，看到了这么多方便快捷的用法之后，是不是很像用呢。但是还是有一些基础的东西需要我们注意，现在我们回头看语法

`解构` ： ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。

所以我们现在可以愉快的这样写了
```javascript
let [a, b, c] = [1, 2, 3];

let [head, ...tail] = [1, 2, 3, 4];
```
但是要注意的是需要等号两边的`模式`相同，而且在解构不成功的情况下，变量的值会等于 undefined。

>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
 
### 默认值
注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，
默认值是不会生效的。
```javascript
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null 不严格等于 undefined
```
如果默认值是一个表达式，那只有在用到这个表达式时才会求值，也就是说你这个变量并没有赋上值。
还有就是默认值可以引用解构赋值的其他变量，但`该变量必须已经声明`。感觉类似块级作用域。

### 对象的解构赋值
对象与数组`解构不同`在于数组是按顺序排列的变量值由位置决定，而对象要找到与属性相同的变量名然后再给对应的变量赋值。

而且需要注意的是这种情况变量声明和赋值是一起的，如果提前声明过就会报错。
```javascript
let foo;
let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration "foo"

let baz;
let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration "baz"

let foo;
({foo} = {foo: 1}); // 成功

let baz;
({bar: baz} = {bar: 1}); // 成功
```
不写第二个let和使用圆括号可以解决这个问题（因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句，所以要用圆括号）。
但是`使用圆括号要注意`,只要有可能导致解构的歧义，就不得使用圆括号,也就是建议只要有可能，就不要在模式中放置圆括号。
##### 不能使用圆括号的情况

+ 1.变量声明语句中，不能带有圆括号。
+ 2.函数参数中，模式不能带有圆括号。
+ 3.赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。

##### 赋值语句的非模式部分，可以使用圆括号。

```javascript
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```
它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，
跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。

嵌套解构的对象中`模式不会被赋值`。

### 字符串的解构赋值
这个就是将字符串转换成了一个`类似数组的对象`，并且其中还有一个`length`的属性
 
### 数字和布尔值的解构赋值
这时候会先将数字和布尔值转为对象。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
`由于undefined和null无法转为对象`，所以对它们进行解构赋值，都会报错。

### 函数参数的解构赋值

```javascript
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3

[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
```
函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。
对于函数内部的代码来说，它们能感受到的参数就是x和y。感觉相当于(x,y)
